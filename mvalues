#!/bin/sh

# Defines what is needed for trigonometry and the scale for intermediary (truncated) results.
TAU=6.283185307179586476925286766559005768394338798750211641949889184615633
internal_scale=$(echo "scale($TAU)" | bc)

# Limits for MVALUES_ROUND.
mvalues_round_default=3
mvalues_round_max=$(expr $internal_scale - 3) # distances rounded output values from truncated ones
mvalues_round_min=-$mvalues_round_max

test -n "$1" || {
	echo "Generates a list of math values, one per line."
	echo "This script uses bc internally."
	echo
	echo "Usage:"
	echo "mvalues constant|linear|sine {specific mode args}"
	echo
	echo "Examples:"
	echo "mvalues constant 8.2 14        # 8.2, 14 times. Also accepts any string that must be repeated."
	echo "mvalues linear 86 81.1 7       # 7 equally separated values from 86 to 81.1 (bounds included)."
	echo "mvalues sine 45 180 15 10 a 9  # sin(x) scaled to a series that starts at 15 and ends at 10 (with a peak that is (a)utomatically computed in this case), for 9 equally separated values of x from 45 to 180 degrees (bounds included)."
	echo
	echo "Environment:"
	echo "MVALUES_ROUND: output precision (maximum number of digits after the decimal point)"
	echo "               if >= 0, the values will be rounded (to the nearest)"
	echo "               if  < 0, the values will be truncated after -MVALUES_ROUND digits"
	echo "               default = $mvalues_round_default, max = $mvalues_round_max, min = $mvalues_round_min"
	exit
}
mode=$1
shift

MVALUES_ROUND=${MVALUES_ROUND:-$mvalues_round_default}
test $MVALUES_ROUND -le $mvalues_round_max || {
	MVALUES_ROUND=$mvalues_round_max
	echo "warning: MVALUES_ROUND out of range, value $mvalues_round_max will be used" >&2
}
test $MVALUES_ROUND -ge $mvalues_round_min || {
	MVALUES_ROUND=$mvalues_round_min
	echo "warning: MVALUES_ROUND out of range, value $mvalues_round_min will be used" >&2
}

# For echoing the bare essential.
remove_trailing_zeros() {
	while read value; do
		echo $value | sed '/\./ s/\.\{0,1\}0\{1,\}$//'
	done
}

# Depending on the environment, bc may echo escaped newlines; we don't want any undesirable character.
filter_output() {
	while read output; do
		echo $output | sed 's/[^-0-9.]//g'
	done
}

# The round() function in bc syntax.
# n is the number that must be rounded to the nearest, using d digits after the decimal point.
bc_round='
define r(n, d) {
	auto r
	if (n < 0) return (-r(-n, d))
	scale = '$internal_scale'
	r = n + 0.5 * 10^-d
	scale = d
	r = r/1
	scale = '$internal_scale'
	return (r)
}'

# Rounds or truncates what it is piped, depending on $1.
round() {
	while read value; do
		if test $1 -ge 0; then
			echo "$bc_round r($value, $1)" | bc | filter_output
		else
			ndigits=$(expr 0 - $1)
			echo $value | sed "s/\([-0-9]*\.\{0,1\}[0-9]\{0,$ndigits\}\)[0-9]\{0,\}/\1/"
		fi
	done
}

# Returns how $1 compares to $2.
compare_values() {
	if test $(printf 'if (%s == %s) {a = 1}; a\n' $1 $2 | bc) -eq 1; then
		echo '='
	elif test $(printf 'if (%s < %s) {a = 1}; a\n' $1 $2 | bc) -eq 1; then
		echo '<'
	else
		echo '>'
	fi
}

# Converts $1 degrees to its value in radians.
degrees2radians() {
	echo "scale = $internal_scale; $1 * $TAU / 360" | bc | filter_output
}

# Gives sin($1), with $1 in radians.
sin() {
	rad=$1
	# This is needed so we can correctly detect that sin(x) == sin(nâ‹…TAU + x).
	while test $(printf 'if (%s > 0) {a = 1}; a\n' $rad | bc -s) -eq 1; do
		rad=$(echo "$rad - $TAU" | bc | filter_output)
	done
	while test $(printf 'if (%s < 0) {a = 1}; a\n' $rad | bc -s) -eq 1; do
		rad=$(echo "$rad + $TAU" | bc | filter_output)
	done

	echo "scale = $internal_scale; s($rad)" | bc -l | filter_output
}

case $mode in
# y = C. Just repeats $value $ntimes times. Nothing else.
constant)
	test $# -eq 2 || {
		echo "2 args required for constant mode" >&2
		echo "value ntimes" >&2
		exit 64
	}
	value=$1; ntimes=$2

	test $ntimes -ge 2 || {
		echo "ntimes must be >= 2" >&2
		exit 1
	}

	while test $ntimes -gt 0; do
		echo $value
		ntimes=$(expr $ntimes - 1)
	done
	exit 0;;

# y = x, for $nvalues values of x equally separated in [$start, $end].
linear)
	test $# -eq 3 || {
		echo "3 args required for linear mode" >&2
		echo "start end nvalues" >&2
		exit 64
	}
	start=$1; end=$2; nvalues=$3

	test $(printf 'if (%s != %s) {a = 1}; a\n' $start $end | bc) -eq 1 || {
		echo "start and end must be different" >&2
		exit 1
	}
	test $nvalues -ge 2 || {
		echo "nvalues must be >= 2" >&2
		exit 1
	}

	nvalues=$(expr $nvalues - 1)
	step=$(echo "scale = $internal_scale; ($end - $start) / $nvalues" | bc | filter_output)

	{
		echo $start
		while test $nvalues -gt 1; do
			nvalues=$(expr $nvalues - 1)
			echo "$end - $nvalues * $step" | bc | filter_output
		done
		echo $end
	} | round $MVALUES_ROUND | remove_trailing_zeros
	exit 0;;

# y = sin(x) * M + A, with M and A automatically computed so the first returned value is $start and the last is $end.
# Uses $nvalues equally separated values of x in [$deg1, $deg2]. Yes, they must be entered in degrees.
# $peak must be given if $start == $end, otherwise just set it to 'a'.
# $peak is the maximum value that can appear in the returned series, when sin(x) == 1. (TODO: define better as the case is implemented)
sine)
	test  $# -eq 6 || {
		echo "6 args required for sine mode" >&2
		echo "deg1 deg2 start end {peak or 'a'} nvalues" >&2
		exit 64
	}
	deg1=$1; deg2=$2; start=$3; end=$4; peak=$5; nvalues=$6

	test $(compare_values $deg1 $deg2) != '=' || {
		echo "deg1 and deg2 must be different" >&2
		exit 1
	}
	test $nvalues -ge 2 || {
		echo "nvalues must be >= 2" >&2
		exit 1
	}

	rad1=$(degrees2radians $deg1)
	rad2=$(degrees2radians $deg2)
	sin1=$(sin $rad1)
	sin2=$(sin $rad2)

	test $(compare_values $start $end) = $(compare_values $sin1 $sin2) || {
		echo "inconsistent sine command, sin(deg1) must compare to sin(deg2) like start compares to end" >&2
		exit 1
	}

	nvalues=$(expr $nvalues - 1)
	step=$(echo "scale = $internal_scale; ($rad2 - $rad1) / $nvalues" | bc | filter_output)

	if test $(compare_values $start $end) = '='; then
		# TODO
		echo "THIS CASE IS NOT IMPLEMENTED YET (start == end)" >&2
		exit 1
	else
		test $peak = 'a' || echo "warning: peak not needed when start != end, set it to 'a' to avoid this message" >&2

		multiplier=$(echo "scale = $internal_scale; ($end - $start) / ($sin2 - $sin1)" | bc | filter_output)
		adder=$(echo "$start - $multiplier * $sin1" | bc | filter_output)
	fi

	{
		echo $start
		while test $nvalues -gt 1; do
			nvalues=$(expr $nvalues - 1)
			echo "scale = $internal_scale; s($rad2 - $nvalues * $step) * $multiplier + $adder" | bc -l | filter_output
		done
		echo $end
	} | round $MVALUES_ROUND | remove_trailing_zeros
	exit 0;;

*)
	echo "'$mode' is not a valid mode" >&2
	exit 1;;
esac
